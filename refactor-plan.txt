================================================================================
BALLPARK API REFACTOR PLAN: Staged Pipeline
================================================================================

GOAL
----
Refactor the robot spherization pipeline into explicit stages with clear
data structures, eliminating the need for scripts to import private modules.


CURRENT PROBLEM
---------------
The interactive script imports from private modules:
  - ballpark._robot.allocate_spheres_for_robot
  - ballpark._robot_refine.compute_mesh_distances_batch
  - ballpark._robot_refine.get_non_contiguous_link_pairs
  - ballpark._similarity.detect_similar_links, get_group_for_link

This is needed for caching expensive operations (mesh distances, similarity
detection) that should only run once at startup.


PROPOSED PIPELINE
-----------------

  URDF ──> [analyze_robot] ──> RobotAnalysis (cached)
                                     │
                                     ├──> [allocate_spheres] ──> link_budgets
                                     │
                                     v
           [compute_spheres_for_robot] ──> RobotSpheresResult


NEW DATA STRUCTURES
-------------------

@dataclass
class RobotAnalysis:
    """Pre-computed robot analysis. Expensive operations, compute once."""

    # Links that have collision geometry
    links_with_collision: list[str]

    # Similarity detection results (groups of geometrically similar links)
    similarity: SimilarityResult

    # Pre-computed mesh distances between non-contiguous link pairs
    mesh_distances: dict[tuple[str, str], float]

    # Link pairs to check for self-collision (non-adjacent, non-contiguous)
    non_contiguous_pairs: list[tuple[str, str]]

    # Joint configuration used for analysis
    joint_cfg: np.ndarray


NEW PUBLIC API
--------------

1. analyze_robot(urdf, joint_cfg=None, ...) -> RobotAnalysis

   Stage 1: Analyze robot structure. Expensive, call once and cache.
   - Detects links with collision geometry
   - Detects similar/symmetric links
   - Computes mesh distances between non-contiguous pairs
   - Returns RobotAnalysis with all cached data

2. allocate_spheres(urdf, target_spheres, analysis=None) -> dict[str, int]

   Allocate sphere budget across links. Fast, can call repeatedly.
   - If analysis provided, uses links_with_collision from it
   - Otherwise computes link weights on the fly
   - Returns {link_name: num_spheres}

3. compute_spheres_for_robot(urdf, ..., analysis=None, link_budgets=None)

   Main function. If analysis/link_budgets not provided, computes them.
   - analysis: Optional pre-computed RobotAnalysis
   - link_budgets: Optional manual sphere allocation
   - Internally runs spherization + optional refinement
   - Returns RobotSpheresResult

4. SimilarityResult gains a method:

   similarity.get_group(link_name) -> list[str] | None

   Returns the similarity group containing this link, or None.


UPDATED PUBLIC EXPORTS (__init__.py)
------------------------------------

# Core types
Sphere
RobotAnalysis          # NEW
RobotSpheresResult
SimilarityResult       # NEW (needed for analysis.similarity)

# Functions
spherize_adaptive_tight   # Mesh-only API
analyze_robot             # NEW - Stage 1
allocate_spheres          # NEW - Allocation helper
compute_spheres_for_robot # Main robot API
export_spheres_to_json

# Configuration
BallparkConfig
get_config
update_config_from_dict
PRESET_CONFIGS


USAGE: SIMPLE (HEADLESS SCRIPT)
-------------------------------

result = ballpark.compute_spheres_for_robot(
    urdf,
    target_spheres=100,
    preset="balanced",
)
ballpark.export_spheres_to_json(result.link_spheres, "spheres.json")


USAGE: ADVANCED (INTERACTIVE SCRIPT)
------------------------------------

# Startup: expensive analysis, do once
analysis = ballpark.analyze_robot(urdf, joint_cfg=initial_cfg)

# Initialize GUI with analysis data
for link in analysis.links_with_collision:
    create_slider(link)

# When user changes total sphere count
budgets = ballpark.allocate_spheres(urdf, target_spheres=50, analysis=analysis)
update_sliders(budgets)

# When user changes a per-link slider, sync similar links
group = analysis.similarity.get_group(changed_link)
if group:
    for other_link in group:
        sync_slider(other_link, new_value)

# When recomputing spheres (budgets changed, params changed, etc.)
result = ballpark.compute_spheres_for_robot(
    urdf,
    analysis=analysis,      # Reuse cached analysis
    link_budgets=budgets,   # Use current allocation
    preset="balanced",
    refine=True,
)


IMPLEMENTATION STEPS
--------------------

1. Create RobotAnalysis dataclass in _robot.py

2. Implement analyze_robot() function:
   - Move similarity detection logic here
   - Move mesh distance computation here
   - Move non-contiguous pair detection here
   - Return RobotAnalysis

3. Rename allocate_spheres_for_robot -> allocate_spheres
   - Add optional analysis parameter
   - If provided, use analysis.links_with_collision

4. Update compute_spheres_for_robot:
   - Add analysis parameter
   - If analysis provided, use it instead of recomputing
   - If link_budgets provided, use them instead of allocating

5. Add get_group() method to SimilarityResult

6. Update __init__.py with new exports

7. Update scripts to use new API:
   - spherize_robot.py: no changes needed (simple API)
   - spherize_robot_interactive.py:
     - Remove private module imports
     - Call analyze_robot() at startup
     - Use analysis.similarity.get_group() for slider sync
     - Pass analysis to compute_spheres_for_robot()

8. Remove now-unused private imports from scripts


FILES TO MODIFY
---------------
- src/ballpark/_robot.py       - Add RobotAnalysis, analyze_robot, update functions
- src/ballpark/_similarity.py  - Add get_group() method to SimilarityResult
- src/ballpark/__init__.py     - Update exports
- scripts/spherize_robot_interactive.py - Use new public API
